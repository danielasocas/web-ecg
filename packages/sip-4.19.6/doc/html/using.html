
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Using SIP &#8212; SIP 4.19.6 Reference Guide</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.19.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/logo_tn.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The SIP Command Line" href="command_line.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="command_line.html" title="The SIP Command Line"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP 4.19.6 Reference Guide</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="using-sip">
<span id="ref-using"></span><h1>Using SIP<a class="headerlink" href="#using-sip" title="Permalink to this headline">¶</a></h1>
<p>Bindings are generated by the SIP code generator from a number of specification
files, typically with a <code class="docutils literal"><span class="pre">.sip</span></code> extension.  Specification files look very
similar to C and C++ header files, but often with additional information (in
the form of a <em>directive</em> or an <em>annotation</em>) and code so that the bindings
generated can be finely tuned.</p>
<div class="section" id="a-simple-c-example">
<span id="ref-simple-c-example"></span><h2>A Simple C++ Example<a class="headerlink" href="#a-simple-c-example" title="Permalink to this headline">¶</a></h2>
<p>We start with a simple example.  Let’s say you have a (fictional) C++ library
that implements a single class called <code class="docutils literal"><span class="pre">Word</span></code>.  The class has one constructor
that takes a <code class="docutils literal"><span class="pre">\0</span></code> terminated character string as its single argument.  The
class has one method called <code class="docutils literal"><span class="pre">reverse()</span></code> which takes no arguments and returns
a <code class="docutils literal"><span class="pre">\0</span></code> terminated character string.  The interface to the class is defined in
a header file called <code class="docutils literal"><span class="pre">word.h</span></code> which might look something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span>

<span class="k">class</span> <span class="nc">Word</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">the_word</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">);</span>

    <span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The corresponding SIP specification file would then look something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">SIP</span> <span class="n">wrapper</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span>

<span class="o">%</span><span class="n">Module</span> <span class="n">word</span>

<span class="k">class</span> <span class="nc">Word</span> <span class="p">{</span>

<span class="o">%</span><span class="n">TypeHeaderCode</span>
<span class="c1">#include &lt;word.h&gt;</span>
<span class="o">%</span><span class="n">End</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">);</span>

    <span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Obviously a SIP specification file looks very much like a C++ (or C) header
file, but SIP does not include a full C++ parser.  Let’s look at the
differences between the two files.</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="directives.html#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive has been added <a class="footnote-reference" href="#id4" id="id1">[1]</a>.  This is used to
name the Python module that is being created, <code class="docutils literal"><span class="pre">word</span></code> in this example.</li>
<li>The <a class="reference internal" href="directives.html#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%TypeHeaderCode</span></code></a> directive has been added.  The text
between this and the following <a class="reference internal" href="directives.html#directive-%End"><code class="xref std std-directive docutils literal"><span class="pre">%End</span></code></a> directive is included
literally in the code that SIP generates.  Normally it is used, as in
this case, to <code class="docutils literal"><span class="pre">#include</span></code> the corresponding C++ (or C) header file <a class="footnote-reference" href="#id5" id="id2">[2]</a>.</li>
<li>The declaration of the private variable <code class="docutils literal"><span class="pre">this_word</span></code> has been removed.
SIP does not support access to either private or protected instance
variables.</li>
</ul>
</div></blockquote>
<p>If we want to we can now generate the C++ code in the current directory by
running the following command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sip</span> <span class="o">-</span><span class="n">c</span> <span class="o">.</span> <span class="n">word</span><span class="o">.</span><span class="n">sip</span>
</pre></div>
</div>
<p>However, that still leaves us with the task of compiling the generated code and
linking it against all the necessary libraries.  It’s much easier to use the
<a class="reference internal" href="build_system.html#ref-build-system"><span class="std std-ref">SIP build system</span></a> to do the whole thing.</p>
<p>Using the SIP build system is simply a matter of writing a small Python script.
In this simple example we will assume that the <code class="docutils literal"><span class="pre">word</span></code> library we are wrapping
and it’s header file are installed in standard system locations and will be
found by the compiler and linker without having to specify any additional
flags.  In a more realistic example your Python script may take command line
options, or search a set of directories to deal with different configurations
and installations.</p>
<p>This is the simplest script (conventionally called <code class="docutils literal"><span class="pre">configure.py</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sipconfig</span>

<span class="c1"># The name of the SIP build file generated by SIP and used by the build</span>
<span class="c1"># system.</span>
<span class="n">build_file</span> <span class="o">=</span> <span class="s2">&quot;word.sbf&quot;</span>

<span class="c1"># Get the SIP configuration information.</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">sipconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="p">()</span>

<span class="c1"># Run SIP to generate the code.</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">config</span><span class="o">.</span><span class="n">sip_bin</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;-b&quot;</span><span class="p">,</span> <span class="n">build_file</span><span class="p">,</span> <span class="s2">&quot;word.sip&quot;</span><span class="p">]))</span>

<span class="c1"># Create the Makefile.</span>
<span class="n">makefile</span> <span class="o">=</span> <span class="n">sipconfig</span><span class="o">.</span><span class="n">SIPModuleMakefile</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">build_file</span><span class="p">)</span>

<span class="c1"># Add the library we are wrapping.  The name doesn&#39;t include any platform</span>
<span class="c1"># specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the</span>
<span class="c1"># &quot;.dll&quot; extension on Windows).</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">extra_libs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;word&quot;</span><span class="p">]</span>

<span class="c1"># Generate the Makefile itself.</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
</pre></div>
</div>
<p>Hopefully this script is self-documenting.  The key parts are the
<code class="docutils literal"><span class="pre">Configuration</span></code> and <code class="docutils literal"><span class="pre">SIPModuleMakefile</span></code> classes.  The build system contains
other Makefile classes, for example to build programs or to call other
Makefiles in sub-directories.</p>
<p>After running the script (using the Python interpreter the extension module is
being created for) the generated C++ code and <code class="docutils literal"><span class="pre">Makefile</span></code> will be in the
current directory.</p>
<p>To compile and install the extension module, just run the following
commands <a class="footnote-reference" href="#id6" id="id3">[3]</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">make</span>
<span class="n">make</span> <span class="n">install</span>
</pre></div>
</div>
<p>That’s all there is to it.</p>
<p>See <a class="reference internal" href="distutils.html#ref-distutils"><span class="std std-ref">Building Your Extension with distutils</span></a> for an example of how to build this example using
distutils.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>All SIP directives start with a <code class="docutils literal"><span class="pre">%</span></code> as the first non-whitespace
character of a line.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>SIP includes many code directives like this.  They differ in where the
supplied code is placed by SIP in the generated code.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>On Windows you might run <code class="docutils literal"><span class="pre">nmake</span></code> or <code class="docutils literal"><span class="pre">mingw32-make</span></code> instead.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id7">
<h2>A Simple C Example<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Let’s now look at a very similar example of wrapping a fictional C library:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">the_word</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">create_word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">);</span>
<span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">(</span><span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">word</span><span class="p">);</span>
</pre></div>
</div>
<p>The corresponding SIP specification file would then look something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">SIP</span> <span class="n">wrapper</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span> <span class="o">*/</span>

<span class="o">%</span><span class="n">Module</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="p">{</span>

<span class="o">%</span><span class="n">TypeHeaderCode</span>
<span class="c1">#include &lt;word.h&gt;</span>
<span class="o">%</span><span class="n">End</span>

    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">the_word</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">create_word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span><span class="n">Factory</span><span class="o">/</span><span class="p">;</span>
<span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">(</span><span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">word</span><span class="p">);</span>
</pre></div>
</div>
<p>Again, let’s look at the differences between the two files.</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="directives.html#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive specifies that the library being
wrapped is implemented in C rather than C++.  Because we are now
supplying an optional argument to the directive we must also specify the
module name as an argument.</li>
<li>The <a class="reference internal" href="directives.html#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%TypeHeaderCode</span></code></a> directive has been added.</li>
<li>The <a class="reference internal" href="annotations.html#function-annotation-Factory"><code class="xref std std-fanno docutils literal"><span class="pre">Factory</span></code></a> annotation has been added to the <code class="docutils literal"><span class="pre">create_word()</span></code>
function.  This tells SIP that a newly created structure is being
returned and it is owned by Python.</li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal"><span class="pre">configure.py</span></code> build system script described in the previous example can
be used for this example without change.</p>
</div>
<div class="section" id="a-more-complex-c-example">
<h2>A More Complex C++ Example<a class="headerlink" href="#a-more-complex-c-example" title="Permalink to this headline">¶</a></h2>
<p>In this last example we will wrap a fictional C++ library that contains a class
that is derived from a Qt class.  This will demonstrate how SIP allows a class
hierarchy to be split across multiple Python extension modules, and will
introduce SIP’s versioning system.</p>
<p>The library contains a single C++ class called <code class="docutils literal"><span class="pre">Hello</span></code> which is derived from
Qt’s <code class="docutils literal"><span class="pre">QLabel</span></code> class.  It behaves just like <code class="docutils literal"><span class="pre">QLabel</span></code> except that the text
in the label is hard coded to be <code class="docutils literal"><span class="pre">Hello</span> <span class="pre">World</span></code>.  To make the example more
interesting we’ll also say that the library only supports Qt v4.2 and later,
and also includes a function called <code class="docutils literal"><span class="pre">setDefault()</span></code> that is not implemented
in the Windows version of the library.</p>
<p>The <code class="docutils literal"><span class="pre">hello.h</span></code> header file looks something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hello</span> <span class="n">library</span><span class="o">.</span>

<span class="c1">#include &lt;qlabel.h&gt;</span>
<span class="c1">#include &lt;qwidget.h&gt;</span>
<span class="c1">#include &lt;qstring.h&gt;</span>

<span class="k">class</span> <span class="nc">Hello</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QLabel</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">needed</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Qt</span> <span class="n">Meta</span><span class="o">-</span><span class="n">Object</span> <span class="n">Compiler</span><span class="o">.</span>
    <span class="n">Q_OBJECT</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Hello</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">private</span><span class="p">:</span>
    <span class="o">//</span> <span class="n">Prevent</span> <span class="n">instances</span> <span class="kn">from</span> <span class="nn">being</span> <span class="n">copied</span><span class="o">.</span>
    <span class="n">Hello</span><span class="p">(</span><span class="n">const</span> <span class="n">Hello</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Hello</span> <span class="o">&amp;</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span> <span class="n">Hello</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">#if !defined(Q_OS_WIN)</span>
<span class="n">void</span> <span class="n">setDefault</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">def</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>The corresponding SIP specification file would then look something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Define the SIP wrapper to the hello library.

%Module hello

%Import QtGui/QtGuimod.sip

%If (Qt_4_2_0 -)

class Hello : public QLabel {

%TypeHeaderCode
#include &lt;hello.h&gt;
%End

public:
    Hello(QWidget *parent /TransferThis/ = 0);

private:
    Hello(const Hello &amp;);
};

%If (!WS_WIN)
void setDefault(const QString &amp;def);
%End

%End
</pre></div>
</div>
<p>Again we look at the differences, but we’ll skip those that we’ve looked at in
previous examples.</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="directives.html#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> directive has been added to specify that we are
extending the class hierarchy defined in the file <code class="docutils literal"><span class="pre">QtGui/QtGuimod.sip</span></code>.
This file is part of PyQt4.  The build system will take care of finding
the file’s exact location.</li>
<li>The <a class="reference internal" href="directives.html#directive-%If"><code class="xref std std-directive docutils literal"><span class="pre">%If</span></code></a> directive has been added to specify that everything
<a class="footnote-reference" href="#id11" id="id8">[4]</a> up to the matching <a class="reference internal" href="directives.html#directive-%End"><code class="xref std std-directive docutils literal"><span class="pre">%End</span></code></a> directive only applies to Qt
v4.2 and later.  <code class="docutils literal"><span class="pre">Qt_4_2_0</span></code> is a <em>tag</em> defined in <code class="docutils literal"><span class="pre">QtCoremod.sip</span></code>
<a class="footnote-reference" href="#id12" id="id9">[5]</a> using the <a class="reference internal" href="directives.html#directive-%Timeline"><code class="xref std std-directive docutils literal"><span class="pre">%Timeline</span></code></a> directive.  <a class="reference internal" href="directives.html#directive-%Timeline"><code class="xref std std-directive docutils literal"><span class="pre">%Timeline</span></code></a>
is used to define a tag for each version of a library’s API you are
wrapping allowing you to maintain all the different versions in a single
SIP specification.  The build system provides support to <code class="docutils literal"><span class="pre">configure.py</span></code>
scripts for working out the correct tags to use according to which
version of the library is actually installed.</li>
<li>The <a class="reference internal" href="annotations.html#argument-annotation-TransferThis"><code class="xref std std-aanno docutils literal"><span class="pre">TransferThis</span></code></a> annotation has been added to the constructor’s
argument.  It specifies that if the argument is not 0 (i.e. the <code class="docutils literal"><span class="pre">Hello</span></code>
instance being constructed has a parent) then ownership of the instance
is transferred from Python to C++.  It is needed because Qt maintains
objects (i.e. instances derived from the <code class="docutils literal"><span class="pre">QObject</span></code> class) in a
hierachy.  When an object is destroyed all of its children are also
automatically destroyed.  It is important, therefore, that the Python
garbage collector doesn’t also try and destroy them.  This is covered in
more detail in <a class="reference internal" href="#ref-object-ownership"><span class="std std-ref">Ownership of Objects</span></a>.  SIP provides many other
annotations that can be applied to arguments, functions and classes.
Multiple annotations are separated by commas.  Annotations may have
values.</li>
<li>The <code class="docutils literal"><span class="pre">=</span></code> operator has been removed.  This operator is not supported by
SIP.</li>
<li>The <a class="reference internal" href="directives.html#directive-%If"><code class="xref std std-directive docutils literal"><span class="pre">%If</span></code></a> directive has been added to specify that everything
up to the matching <a class="reference internal" href="directives.html#directive-%End"><code class="xref std std-directive docutils literal"><span class="pre">%End</span></code></a> directive does not apply to Windows.
<code class="docutils literal"><span class="pre">WS_WIN</span></code> is another tag defined by PyQt4, this time using the
<a class="reference internal" href="directives.html#directive-%Platforms"><code class="xref std std-directive docutils literal"><span class="pre">%Platforms</span></code></a> directive.  Tags defined by the
<a class="reference internal" href="directives.html#directive-%Platforms"><code class="xref std std-directive docutils literal"><span class="pre">%Platforms</span></code></a> directive are mutually exclusive, i.e. only one
may be valid at a time <a class="footnote-reference" href="#id13" id="id10">[6]</a>.</li>
</ul>
</div></blockquote>
<p>One question you might have at this point is why bother to define the private
copy constructor when it can never be called from Python?  The answer is to
prevent the automatic generation of a public copy constructor.</p>
<p>We now look at the <code class="docutils literal"><span class="pre">configure.py</span></code> script.  This is a little different to the
script in the previous examples for two related reasons.</p>
<p>Firstly, PyQt4 includes a pure Python module called <code class="docutils literal"><span class="pre">pyqtconfig</span></code> that extends
the SIP build system for modules, like our example, that build on top of PyQt4.
It deals with the details of which version of Qt is being used (i.e. it
determines what the correct tags are) and where it is installed.  This is
called a module’s configuration module.</p>
<p>Secondly, we generate a configuration module (called <code class="docutils literal"><span class="pre">helloconfig</span></code>) for our
own <code class="docutils literal"><span class="pre">hello</span></code> module.  There is no need to do this, but if there is a chance
that somebody else might want to extend your C++ library then it would make
life easier for them.</p>
<p>Now we have two scripts.  First the <code class="docutils literal"><span class="pre">configure.py</span></code> script:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sipconfig</span>
<span class="kn">from</span> <span class="nn">PyQt4</span> <span class="k">import</span> <span class="n">pyqtconfig</span>

<span class="c1"># The name of the SIP build file generated by SIP and used by the build</span>
<span class="c1"># system.</span>
<span class="n">build_file</span> <span class="o">=</span> <span class="s2">&quot;hello.sbf&quot;</span>

<span class="c1"># Get the PyQt4 configuration information.</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="p">()</span>

<span class="c1"># Get the extra SIP flags needed by the imported PyQt4 modules.  Note that</span>
<span class="c1"># this normally only includes those flags (-x and -t) that relate to SIP&#39;s</span>
<span class="c1"># versioning system.</span>
<span class="n">pyqt_sip_flags</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">pyqt_sip_flags</span>

<span class="c1"># Run SIP to generate the code.  Note that we tell SIP where to find the qt</span>
<span class="c1"># module&#39;s specification files using the -I flag.</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">config</span><span class="o">.</span><span class="n">sip_bin</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;-b&quot;</span><span class="p">,</span> <span class="n">build_file</span><span class="p">,</span> <span class="s2">&quot;-I&quot;</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">pyqt_sip_dir</span><span class="p">,</span> <span class="n">pyqt_sip_flags</span><span class="p">,</span> <span class="s2">&quot;hello.sip&quot;</span><span class="p">]))</span>

<span class="c1"># We are going to install the SIP specification file for this module and</span>
<span class="c1"># its configuration module.</span>
<span class="n">installs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">installs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;hello.sip&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">default_sip_dir</span><span class="p">,</span> <span class="s2">&quot;hello&quot;</span><span class="p">)])</span>

<span class="n">installs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;helloconfig.py&quot;</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">default_mod_dir</span><span class="p">])</span>

<span class="c1"># Create the Makefile.  The QtGuiModuleMakefile class provided by the</span>
<span class="c1"># pyqtconfig module takes care of all the extra preprocessor, compiler and</span>
<span class="c1"># linker flags needed by the Qt library.</span>
<span class="n">makefile</span> <span class="o">=</span> <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">QtGuiModuleMakefile</span><span class="p">(</span>
    <span class="n">configuration</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
    <span class="n">build_file</span><span class="o">=</span><span class="n">build_file</span><span class="p">,</span>
    <span class="n">installs</span><span class="o">=</span><span class="n">installs</span>
<span class="p">)</span>

<span class="c1"># Add the library we are wrapping.  The name doesn&#39;t include any platform</span>
<span class="c1"># specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the</span>
<span class="c1"># &quot;.dll&quot; extension on Windows).</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">extra_libs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">]</span>

<span class="c1"># Generate the Makefile itself.</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>

<span class="c1"># Now we create the configuration module.  This is done by merging a Python</span>
<span class="c1"># dictionary (whose values are normally determined dynamically) with a</span>
<span class="c1"># (static) template.</span>
<span class="n">content</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Publish where the SIP specifications for this module will be</span>
    <span class="c1"># installed.</span>
    <span class="s2">&quot;hello_sip_dir&quot;</span><span class="p">:</span>    <span class="n">config</span><span class="o">.</span><span class="n">default_sip_dir</span><span class="p">,</span>

    <span class="c1"># Publish the set of SIP flags needed by this module.  As these are the</span>
    <span class="c1"># same flags needed by the qt module we could leave it out, but this</span>
    <span class="c1"># allows us to change the flags at a later date without breaking</span>
    <span class="c1"># scripts that import the configuration module.</span>
    <span class="s2">&quot;hello_sip_flags&quot;</span><span class="p">:</span>  <span class="n">pyqt_sip_flags</span>
<span class="p">}</span>

<span class="c1"># This creates the helloconfig.py module from the helloconfig.py.in</span>
<span class="c1"># template and the dictionary.</span>
<span class="n">sipconfig</span><span class="o">.</span><span class="n">create_config_module</span><span class="p">(</span><span class="s2">&quot;helloconfig.py&quot;</span><span class="p">,</span> <span class="s2">&quot;helloconfig.py.in&quot;</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we have the <code class="docutils literal"><span class="pre">helloconfig.py.in</span></code> template script:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">PyQt4</span> <span class="k">import</span> <span class="n">pyqtconfig</span>

<span class="c1"># These are installation specific values created when Hello was configured.</span>
<span class="c1"># The following line will be replaced when this template is used to create</span>
<span class="c1"># the final configuration module.</span>
<span class="c1"># @SIP_CONFIGURATION@</span>

<span class="k">class</span> <span class="nc">Configuration</span><span class="p">(</span><span class="n">pyqtconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The class that represents Hello configuration values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise an instance of the class.</span>

<span class="sd">        sub_cfg is the list of sub-class configurations.  It should be None</span>
<span class="sd">        when called normally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is all standard code to be copied verbatim except for the</span>
        <span class="c1"># name of the module containing the super-class.</span>
        <span class="k">if</span> <span class="n">sub_cfg</span><span class="p">:</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">sub_cfg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cfg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pkg_config</span><span class="p">)</span>

        <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">HelloModuleMakefile</span><span class="p">(</span><span class="n">pyqtconfig</span><span class="o">.</span><span class="n">QtGuiModuleMakefile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The Makefile class for modules that %Import hello.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finalise the macros.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure our C++ library is linked.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_libs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

        <span class="c1"># Let the super-class do what it needs to.</span>
        <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">QtGuiModuleMakefile</span><span class="o">.</span><span class="n">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, we hope that the scripts are self documenting.</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td>Some parts of a SIP specification aren’t subject to version control.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td>Actually in <code class="docutils literal"><span class="pre">versions.sip</span></code>.  PyQt4 uses the <a class="reference internal" href="directives.html#directive-%Include"><code class="xref std std-directive docutils literal"><span class="pre">%Include</span></code></a>
directive to split the SIP specification for Qt across a large number of
separate <code class="docutils literal"><span class="pre">.sip</span></code> files.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[6]</a></td><td>Tags can also be defined by the <a class="reference internal" href="directives.html#directive-%Feature"><code class="xref std std-directive docutils literal"><span class="pre">%Feature</span></code></a> directive.  These
tags are not mutually exclusive, i.e. any number may be valid at a time.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="ownership-of-objects">
<span id="ref-object-ownership"></span><h2>Ownership of Objects<a class="headerlink" href="#ownership-of-objects" title="Permalink to this headline">¶</a></h2>
<p>When a C++ instance is wrapped a corresponding Python object is created.  The
Python object behaves as you would expect in regard to garbage collection - it
is garbage collected when its reference count reaches zero.  What then happens
to the corresponding C++ instance?  The obvious answer might be that the
instance’s destructor is called.  However the library API may say that when the
instance is passed to a particular function, the library takes ownership of the
instance, i.e. responsibility for calling the instance’s destructor is
transferred from the SIP generated module to the library.</p>
<p>Ownership of an instance may also be associated with another instance.  The
implication being that the owned instance will automatically be destroyed if
the owning instance is destroyed.  SIP keeps track of these relationships to
ensure that Python’s cyclic garbage collector can detect and break any
reference cycles between the owning and owned instances.  The association is
implemented as the owning instance taking a reference to the owned instance.</p>
<p>The TransferThis, Transfer and TransferBack annotations are used to specify
where, and it what direction, transfers of ownership happen.  It is very
important that these are specified correctly to avoid crashes (where both
Python and C++ call the destructor) and memory leaks (where neither Python and
C++ call the destructor).</p>
<p>This applies equally to C structures where the structure is returned to the
heap using the <code class="docutils literal"><span class="pre">free()</span></code> function.</p>
<p>See also <a class="reference internal" href="c_api.html#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal"><span class="pre">sipTransferTo()</span></code></a>, <a class="reference internal" href="c_api.html#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal"><span class="pre">sipTransferBack()</span></code></a> and
<a class="reference internal" href="c_api.html#c.sipTransferBreak" title="sipTransferBreak"><code class="xref c c-func docutils literal"><span class="pre">sipTransferBreak()</span></code></a>.</p>
</div>
<div class="section" id="types-and-meta-types">
<span id="ref-types-metatypes"></span><h2>Types and Meta-types<a class="headerlink" href="#types-and-meta-types" title="Permalink to this headline">¶</a></h2>
<p>Every Python object (with the exception of the <code class="xref py py-class docutils literal"><span class="pre">object</span></code> object itself)
has a meta-type and at least one super-type.  By default an object’s meta-type
is the meta-type of its first super-type.</p>
<p>SIP implements two super-types, <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.simplewrapper</span></code></a> and
<a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.wrapper</span></code></a>, and a meta-type, <a class="reference internal" href="python_api.html#sip.wrappertype" title="sip.wrappertype"><code class="xref py py-class docutils literal"><span class="pre">sip.wrappertype</span></code></a>.</p>
<p><a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.simplewrapper</span></code></a> is the super-type of <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.wrapper</span></code></a>.  The
super-type of <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.simplewrapper</span></code></a> is <code class="xref py py-class docutils literal"><span class="pre">object</span></code>.</p>
<p><a class="reference internal" href="python_api.html#sip.wrappertype" title="sip.wrappertype"><code class="xref py py-class docutils literal"><span class="pre">sip.wrappertype</span></code></a> is the meta-type of both <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.simplewrapper</span></code></a>
and <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.wrapper</span></code></a>.  The super-type of <a class="reference internal" href="python_api.html#sip.wrappertype" title="sip.wrappertype"><code class="xref py py-class docutils literal"><span class="pre">sip.wrappertype</span></code></a> is
<code class="xref py py-class docutils literal"><span class="pre">type</span></code>.</p>
<p><a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.wrapper</span></code></a> supports the concept of object ownership described in
<a class="reference internal" href="#ref-object-ownership"><span class="std std-ref">Ownership of Objects</span></a> and, by default, is the super-type of all the types
that SIP generates.</p>
<p><a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.simplewrapper</span></code></a> does not support the concept of object ownership but
SIP generated types that are sub-classed from it have Python objects that take
less memory.</p>
<p>SIP allows a class’s meta-type and super-type to be explicitly specified using
the <a class="reference internal" href="annotations.html#class-annotation-Metatype"><code class="xref std std-canno docutils literal"><span class="pre">Metatype</span></code></a> and <a class="reference internal" href="annotations.html#class-annotation-Supertype"><code class="xref std std-canno docutils literal"><span class="pre">Supertype</span></code></a> class annotations.</p>
<p>SIP also allows the default meta-type and super-type to be changed for a module
using the <a class="reference internal" href="directives.html#directive-%DefaultMetatype"><code class="xref std std-directive docutils literal"><span class="pre">%DefaultMetatype</span></code></a> and <a class="reference internal" href="directives.html#directive-%DefaultSupertype"><code class="xref std std-directive docutils literal"><span class="pre">%DefaultSupertype</span></code></a>
directives.  Unlike the default super-type, the default meta-type is inherited
by importing modules.</p>
<p>If you want to use your own meta-type or super-type then they must be
sub-classed from one of the SIP provided types.  Your types must be registered
using <a class="reference internal" href="c_api.html#c.sipRegisterPyType" title="sipRegisterPyType"><code class="xref c c-func docutils literal"><span class="pre">sipRegisterPyType()</span></code></a>.  This is normally done in code specified
using the <a class="reference internal" href="directives.html#directive-%InitialisationCode"><code class="xref std std-directive docutils literal"><span class="pre">%InitialisationCode</span></code></a> directive.</p>
<p>As an example, PyQt4 uses <a class="reference internal" href="directives.html#directive-%DefaultMetatype"><code class="xref std std-directive docutils literal"><span class="pre">%DefaultMetatype</span></code></a> to specify a new
meta-type that handles the interaction with Qt’s own meta-type system.  It also
uses <a class="reference internal" href="directives.html#directive-%DefaultSupertype"><code class="xref std std-directive docutils literal"><span class="pre">%DefaultSupertype</span></code></a> to specify that the smaller
<a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.simplewrapper</span></code></a> super-type is normally used.  Finally it uses
<a class="reference internal" href="annotations.html#class-annotation-Supertype"><code class="xref std std-canno docutils literal"><span class="pre">Supertype</span></code></a> as an annotation of the <code class="docutils literal"><span class="pre">QObject</span></code> class to override the
default and use <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal"><span class="pre">sip.wrapper</span></code></a> as the super-type so that the parent/child
relationships of <code class="docutils literal"><span class="pre">QObject</span></code> instances are properly maintained.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is not possible to define new super-types or meta-types if the limited
Python API is enabled.</p>
</div>
</div>
<div class="section" id="lazy-type-attributes">
<span id="ref-lazy-type-attributes"></span><h2>Lazy Type Attributes<a class="headerlink" href="#lazy-type-attributes" title="Permalink to this headline">¶</a></h2>
<p>Instead of populating a wrapped type’s dictionary with its attributes (or
descriptors for those attributes) SIP only creates objects for those attributes
when they are actually needed.  This is done to reduce the memory footprint and
start up time when used to wrap large libraries with hundreds of classes and
tens of thousands of attributes.</p>
<p>SIP allows you to extend the handling of lazy attributes to your own attribute
types by allowing you to register an attribute getter handler (using
<a class="reference internal" href="c_api.html#c.sipRegisterAttributeGetter" title="sipRegisterAttributeGetter"><code class="xref c c-func docutils literal"><span class="pre">sipRegisterAttributeGetter()</span></code></a>).  This will be called just before a
type’s dictionary is accessed for the first time.</p>
</div>
<div class="section" id="overflow-checking">
<h2>Overflow Checking<a class="headerlink" href="#overflow-checking" title="Permalink to this headline">¶</a></h2>
<p>By default SIP does not check for overflow when converting Python number
objects to C/C++ types.  Overflowed values are undefined - it cannot be assumed
that upper bits are simply discarded.</p>
<p>SIP v4.19.4 allowed overflow checking to be enabled and disabled by the wrapper
author (using :c:func`sipEnableOverflowChecking()`) or by the application
developer (using :py:func`sip.enableoverflowchecking()`).</p>
<p>It is recommended that wrapper authors should always enable overflow checking
by default.</p>
</div>
<div class="section" id="support-for-python-s-buffer-interface">
<h2>Support for Python’s Buffer Interface<a class="headerlink" href="#support-for-python-s-buffer-interface" title="Permalink to this headline">¶</a></h2>
<p>SIP supports Python’s buffer interface in that whenever C/C++ requires a
<code class="docutils literal"><span class="pre">char</span></code> or <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> type then any Python type that supports the buffer
interface (including ordinary Python strings) can be used.</p>
<p>If a buffer is made up of a number of segments then all but the first will be
ignored.</p>
</div>
<div class="section" id="support-for-wide-characters">
<h2>Support for Wide Characters<a class="headerlink" href="#support-for-wide-characters" title="Permalink to this headline">¶</a></h2>
<p>SIP v4.6 introduced support for wide characters (i.e. the <code class="docutils literal"><span class="pre">wchar_t</span></code> type).
Python’s C API includes support for converting between unicode objects and wide
character strings and arrays.  When converting from a unicode object to wide
characters SIP creates the string or array on the heap (using memory allocated
using <a class="reference internal" href="c_api.html#c.sipMalloc" title="sipMalloc"><code class="xref c c-func docutils literal"><span class="pre">sipMalloc()</span></code></a>).  This then raises the problem of how this memory
is subsequently freed.</p>
<p>The following describes how SIP handles this memory in the different situations
where this is an issue.</p>
<blockquote>
<div><ul class="simple">
<li>When a wide string or array is passed to a function or method then the
memory is freed (using <a class="reference internal" href="c_api.html#c.sipFree" title="sipFree"><code class="xref c c-func docutils literal"><span class="pre">sipFree()</span></code></a>) after that function or method
returns.</li>
<li>When a wide string or array is returned from a virtual method then SIP
does not free the memory until the next time the method is called.</li>
<li>When an assignment is made to a wide string or array instance variable
then SIP does not first free the instance’s current string or array.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="the-python-global-interpreter-lock">
<span id="ref-gil"></span><h2>The Python Global Interpreter Lock<a class="headerlink" href="#the-python-global-interpreter-lock" title="Permalink to this headline">¶</a></h2>
<p>Python’s Global Interpretor Lock (GIL) must be acquired before calls can be
made to the Python API.  It should also be released when a potentially
blocking call to C/C++ library is made in order to allow other Python threads
to be executed.  In addition, some C/C++ libraries may implement their own
locking strategies that conflict with the GIL causing application deadlocks.
SIP provides ways of specifying when the GIL is released and acquired to
ensure that locking problems can be avoided.</p>
<p>SIP always ensures that the GIL is acquired before making calls to the Python
API.  By default SIP does not release the GIL when making calls to the C/C++
library being wrapped.  The <a class="reference internal" href="annotations.html#function-annotation-ReleaseGIL"><code class="xref std std-fanno docutils literal"><span class="pre">ReleaseGIL</span></code></a> annotation can be used to
override this behaviour when required.</p>
<p>If SIP is given the <a class="reference internal" href="command_line.html#cmdoption-sip-g"><code class="xref std std-option docutils literal"><span class="pre">-g</span></code></a> command line option then the default
behaviour is changed and SIP releases the GIL every time is makes calls to the
C/C++ library being wrapped.  The <a class="reference internal" href="annotations.html#function-annotation-HoldGIL"><code class="xref std std-fanno docutils literal"><span class="pre">HoldGIL</span></code></a> annotation can be used to
override this behaviour when required.</p>
</div>
<div class="section" id="managing-incompatible-apis">
<span id="ref-incompat-apis"></span><h2>Managing Incompatible APIs<a class="headerlink" href="#managing-incompatible-apis" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.9.</span></p>
</div>
<p>Sometimes it is necessary to change the way something is wrapped in a way that
introduces an incompatibility.  For example a new feature of Python may
suggest that something may be wrapped in a different way to exploit that
feature.</p>
<p>SIP’s <a class="reference internal" href="directives.html#directive-%Feature"><code class="xref std std-directive docutils literal"><span class="pre">%Feature</span></code></a> directive could be used to provide two different
implementations.  However this would mean that the choice between the two
implementations would have to be made when building the generated module
potentially causing all sorts of deployment problems.  It may also require
applications to work out which implementation was available and to change
their behaviour accordingly.</p>
<p>Instead SIP provides limited support for providing multiple implementations
(of classes, mapped types and functions) that can be selected by an
application at run-time.  It is then up to the application developer how they
want to manage the migration from the old API to the new, incompatible API.</p>
<p>This support is implemented in three parts.</p>
<p>Firstly the <a class="reference internal" href="directives.html#directive-%API"><code class="xref std std-directive docutils literal"><span class="pre">%API</span></code></a> directive is used to define the name of an API
and its default version number.  The default version number is the one used if
an application doesn’t explicitly set the version number to use.</p>
<p>Secondly the <a class="reference internal" href="annotations.html#class-annotation-API"><code class="xref std std-canno docutils literal"><span class="pre">API</span> <span class="pre">class</span></code></a>, <a class="reference internal" href="annotations.html#mapped-type-annotation-API"><code class="xref std std-manno docutils literal"><span class="pre">mapped</span> <span class="pre">type</span></code></a> or
<a class="reference internal" href="annotations.html#function-annotation-API"><code class="xref std std-fanno docutils literal"><span class="pre">function</span></code></a> annotation is applied accordingly to specify the API
and range of version numbers that a particular class, mapped type or function
implementation should be enabled for.</p>
<p>Finally the application calls <a class="reference internal" href="python_api.html#sip.setapi" title="sip.setapi"><code class="xref py py-func docutils literal"><span class="pre">sip.setapi()</span></code></a> to specify the version number
of the API that should be enabled.  This call must be made before any module
that has multiple implementations is imported for the first time.</p>
<p>Note this mechanism is not intended as a way or providing equally valid
alternative APIs.  For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">API</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">MyAPI</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Baz</span> <span class="p">:</span> <span class="n">Foo</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">bar</span><span class="p">()</span> <span class="o">/</span><span class="n">API</span><span class="o">=</span><span class="n">MyAPI</span><span class="p">:</span><span class="mi">2</span><span class="o">-/</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the following Python code is executed then an exception will be raised:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Baz</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
</pre></div>
</div>
<p>This is because when version 1 of the <em>MyAPI</em> API (the default) is enabled
there is no <em>Baz.bar()</em> implementation and <em>Foo.bar()</em> will not be called
instead as might be expected.</p>
</div>
<div class="section" id="building-a-private-copy-of-the-sip-module">
<span id="ref-private-sip"></span><h2>Building a Private Copy of the <code class="docutils literal"><span class="pre">sip</span></code> Module<a class="headerlink" href="#building-a-private-copy-of-the-sip-module" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.12.</span></p>
</div>
<p>The <code class="docutils literal"><span class="pre">sip</span></code> module is intended to be be used by all the SIP generated modules
of a particular Python installation.  For example PyQt4 and PyQt5 are
completely independent of each other but will use the same <code class="docutils literal"><span class="pre">sip</span></code> module.
However, this means that all the generated modules must be built against a
compatible version of SIP.  If you do not have complete control over the
Python installation then this may be difficult or even impossible to achieve.</p>
<p>To get around this problem you can build a private copy of the <code class="docutils literal"><span class="pre">sip</span></code> module
that has a different name and/or is placed in a different Python package.  To
do this you use the <a class="reference internal" href="installation.html#cmdoption-configure-py-sip-module"><code class="xref std std-option docutils literal"><span class="pre">--sip-module</span></code></a> option
to specify the name (optionally including a package name) of your private copy.</p>
<p>As well as building the private copy of the module, the version of the
<code class="docutils literal"><span class="pre">sip.h</span></code> header file will also be specific to the private copy.  You will
probably also want to use the <a class="reference internal" href="installation.html#cmdoption-configure-py-e"><code class="xref std std-option docutils literal"><span class="pre">--incdir</span></code></a> option to
specify the directory where the header file will be installed to avoid
overwriting a copy of the default version that might already be installed.</p>
<p>When building your generated modules you must ensure that they <code class="docutils literal"><span class="pre">#include</span></code> the
private copy of <code class="docutils literal"><span class="pre">sip.h</span></code> instead of any default version.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Using SIP</a><ul>
<li><a class="reference internal" href="#a-simple-c-example">A Simple C++ Example</a></li>
<li><a class="reference internal" href="#id7">A Simple C Example</a></li>
<li><a class="reference internal" href="#a-more-complex-c-example">A More Complex C++ Example</a></li>
<li><a class="reference internal" href="#ownership-of-objects">Ownership of Objects</a></li>
<li><a class="reference internal" href="#types-and-meta-types">Types and Meta-types</a></li>
<li><a class="reference internal" href="#lazy-type-attributes">Lazy Type Attributes</a></li>
<li><a class="reference internal" href="#overflow-checking">Overflow Checking</a></li>
<li><a class="reference internal" href="#support-for-python-s-buffer-interface">Support for Python’s Buffer Interface</a></li>
<li><a class="reference internal" href="#support-for-wide-characters">Support for Wide Characters</a></li>
<li><a class="reference internal" href="#the-python-global-interpreter-lock">The Python Global Interpreter Lock</a></li>
<li><a class="reference internal" href="#managing-incompatible-apis">Managing Incompatible APIs</a></li>
<li><a class="reference internal" href="#building-a-private-copy-of-the-sip-module">Building a Private Copy of the <code class="docutils literal"><span class="pre">sip</span></code> Module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="command_line.html"
                        title="next chapter">The SIP Command Line</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="command_line.html" title="The SIP Command Line"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP 4.19.6 Reference Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017 Riverbank Computing Limited.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>